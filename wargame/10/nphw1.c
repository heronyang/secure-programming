/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2011 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Data declarations

extern _UNKNOWN start; // weak
extern char delim[]; // idb
extern char aInitPipeFail[16]; // weak
extern char aForkFail[11]; // weak
extern char aUnknownCommand[19]; // weak
extern char asc_8049EE8[3]; // weak
extern int (__cdecl *off_8049EEC[5])(int, int); // weak
extern char value[]; // idb
extern char name[]; // idb
extern char aHomeNphw1Root[]; // idb
extern char aPwd[]; // idb
extern char s2[]; // idb
extern char format[]; // idb
extern int (*_frame_dummy_init_array_entry[2])(); // weak
extern int (*_do_global_dtors_aux_fini_array_entry)(); // weak
extern int savefd; // idb
extern FILE *stderr; // idb
extern char completed_6590; // weak
extern int front; // weak
extern int rear; // weak
extern char *cmdline; // idb
// extern _UNKNOWN _gmon_start__; weak

//-------------------------------------------------------------------------
// Function declarations

int __cdecl init_proc();
// int dup2(int fd, int fd2);
// int strcmp(const char *s1, const char *s2);
// ssize_t read(int fd, void *buf, size_t nbytes);
// int dup(int fd);
// void free(void *ptr);
// void *memcpy(void *dest, const void *src, size_t n);
// void bzero(void *s, size_t n);
// int chdir(const char *path);
// int __fastcall __stack_chk_fail(_DWORD); weak
// __pid_t wait(void *stat_loc);
// int execvp(const char *file, char *const *argv);
// char *strcpy(char *dest, const char *src);
// char *getenv(const char *name);
// void *malloc(size_t size);
// int __gmon_start__(void); weak
// void exit(int status);
// char *strchr(const char *s, int c);
// size_t strlen(const char *s);
// int setenv(const char *name, const char *value, int replace);
// int fprintf(FILE *stream, const char *format, ...);
// ssize_t write(int fd, const void *buf, size_t n);
// int fcntl(int fd, int cmd, ...);
// void *memset(void *s, int c, size_t n);
// __pid_t wait3(void *stat_loc, int options, struct rusage *usage);
// int pipe(int *pipedes);
// int vsprintf(char *s, const char *format, __gnuc_va_list arg);
// char *strtok(char *s, const char *delim);
// __pid_t fork(void);
// int close(int fd);
void __cdecl _x86_get_pc_thunk_bx();
signed int __cdecl deregister_tm_clones();
int __cdecl register_tm_clones();
void __cdecl _do_global_dtors_aux();
int __cdecl frame_dummy();
char **__cdecl passCmdline();
char *__cdecl splitCmdline();
int __cdecl parseArgv();
signed int __cdecl printEnv();
signed int __cdecl setEnv();
int __cdecl getResult(int fd, void *buf); // idb
void __cdecl sendResult(const char *buf);
int __cdecl closePipes(int a1, int a2);
int __cdecl exeCmd(unsigned int a1);
int __cdecl nextLine();
void __cdecl main(int a1, int a2);
int __cdecl passPipe();
void *__cdecl addPipe(const char *src, int a2);
void __cdecl delPipe(char *s);
void errexit(const char *a1, ...);
void __cdecl myexit(int status);
__pid_t __cdecl reaper();
signed int __cdecl readline(int fd, void **a2);
int __cdecl _libc_csu_init();
void __cdecl term_proc();



//----- (0804897D) --------------------------------------------------------
char **__cdecl passCmdline()
{
  int v0; // eax@1
  int v1; // eax@1
  char **result; // eax@1
  int v3; // [sp+2Ch] [bp-Ch]@1

  v3 = *MK_FP(__GS__, 20);
  
  *(&cmdline + 11006) = (char *)malloc(9u);
  bzero(*(&cmdline + 11006), 9u);
  v0 = (int)*(&cmdline + 11006);
  *(_DWORD *)*(&cmdline + 11006) = 1852404336;
  *(_DWORD *)(v0 + 4) = 1986946420;
  *(_BYTE *)(v0 + 8) = 0;
  *(&cmdline + 11005) = (char *)printEnv;
  
  *(&cmdline + 11008) = (char *)malloc(7u);
  bzero(*(&cmdline + 11008), 7u);
  v1 = (int)*(&cmdline + 11008);
  *(_DWORD *)*(&cmdline + 11008) = 1702126963;
  *(_WORD *)(v1 + 4) = 30318;
  *(_BYTE *)(v1 + 6) = 0;
  *(&cmdline + 11007) = (char *)setEnv;
  
  passPipe();
  result = &cmdline;
  if ( *MK_FP(__GS__, 20) != v3 )
    __stack_chk_fail(*MK_FP(__GS__, 20) ^ v3);
  return result;
}
// 8048720: using guessed type int __fastcall __stack_chk_fail(_DWORD);

//----- (08048A70) --------------------------------------------------------
char *__cdecl splitCmdline()
{
  size_t v0; // eax@2
  size_t v1; // eax@2
  size_t v2; // eax@2
  char *result; // eax@5
  char *i; // [sp+18h] [bp-10h]@1
  char *src; // [sp+1Ch] [bp-Ch]@1

  //   / .
  src = strtok(cmdline, L" >|=\n");
  for ( i = 0; src && (signed int)i <= 9999; ++i )
  {
    v0 = strlen(src);
    (&cmdline)[4 * (_DWORD)i + 4] = (char *)malloc(v0 + 1);
    v1 = strlen(src);
    bzero((&cmdline)[4 * (_DWORD)i + 4], v1 + 1);
    v2 = strlen(src);
    memcpy((&cmdline)[4 * (_DWORD)i + 4], src, v2);
    (&cmdline)[4 * (_DWORD)i + 4][strlen(src)] = 0;
    src = strtok(0, L" >|=\n");
  }
  result = i;
  *(&cmdline + 10001) = i;
  return result;
}

//----- (08048B5F) --------------------------------------------------------
int __cdecl parseArgv()
{
  size_t v0; // eax@16
  size_t v1; // eax@16
  size_t v2; // eax@16
  char *v3; // eax@16
  int result; // eax@23
  signed int v5; // [sp+14h] [bp-24h]@1
  signed int k; // [sp+14h] [bp-24h]@21
  char *v7; // [sp+18h] [bp-20h]@1
  signed int v8; // [sp+1Ch] [bp-1Ch]@1
  int v9; // [sp+20h] [bp-18h]@7
  signed int i; // [sp+24h] [bp-14h]@7
  int v11; // [sp+28h] [bp-10h]@12
  signed int j; // [sp+2Ch] [bp-Ch]@12

  v8 = 0;
  v5 = (signed int)*(&cmdline + 11003);
  v7 = 0;
  while ( (signed int)*(&cmdline + 10001) > v5 )
  {
    if ( strcmp((&cmdline)[4 * v5 + 4], L"") )
    {
      if ( strcmp((&cmdline)[4 * v5 + 4], L">|=\n") )
      {
        if ( strchr((&cmdline)[4 * v5 + 4], 124) )
        {
          v9 = 0;
          for ( i = 1; (&cmdline)[4 * v5 + 4][i]; ++i )
            v9 = 10 * v9 + (&cmdline)[4 * v5 + 4][i] - 48;
          *(&cmdline + 11002) = v7;
          (&cmdline)[4 * (_DWORD)(v7 + 10000) + 8] = 0;
          v8 = 0;
          exeCmd(3u);
          v7 = 0;
        }
        else
        {
          if ( strchr((&cmdline)[4 * v5 + 4], 33) )
          {
            v11 = 0;
            for ( j = 1; (&cmdline)[4 * v5 + 4][j]; ++j )
              v11 = 10 * v11 + (&cmdline)[4 * v5 + 4][j] - 48;
            *(&cmdline + 11002) = v7;
            (&cmdline)[4 * (_DWORD)(v7 + 10000) + 8] = 0;
            v8 = 0;
            exeCmd(4u);
            v7 = 0;
          }
          else
          {
            v8 = 1;
            v0 = strlen((&cmdline)[4 * v5 + 4]);
            (&cmdline)[4 * (_DWORD)(v7 + 10000) + 8] = (char *)malloc(v0 + 1);
            v1 = strlen((&cmdline)[4 * v5 + 4]);
            bzero((&cmdline)[4 * (_DWORD)(v7 + 10000) + 8], v1 + 1);
            v2 = strlen((&cmdline)[4 * v5 + 4]);
            memcpy((&cmdline)[4 * (_DWORD)(v7 + 10000) + 8], (&cmdline)[4 * v5 + 4], v2);
            v3 = v7++;
            (&cmdline)[4 * (_DWORD)(v3 + 10000) + 8][strlen((&cmdline)[4 * v5 + 4])] = 0;
          }
        }
      }
      else
      {
        *(&cmdline + 11002) = v7;
        (&cmdline)[4 * (_DWORD)(v7 + 10000) + 8] = 0;
        v8 = 0;
        exeCmd(0);
        v7 = 0;
      }
    }
    else
    {
      *(&cmdline + 11002) = v7;
      (&cmdline)[4 * (_DWORD)(v7 + 10000) + 8] = 0;
      v8 = 0;
      exeCmd(2u);
      v7 = 0;
    }
    *(&cmdline + 11003) = (char *)(v5++ + 1);
  }
  if ( v8 )
  {
    *(&cmdline + 11002) = v7;
    (&cmdline)[4 * (_DWORD)(v7 + 10000) + 8] = 0;
    exeCmd(1u);
  }
  *(&cmdline + 11003) = 0;
  for ( k = 0; ; ++k )
  {
    result = (int)*(&cmdline + 10001);
    if ( (signed int)*(&cmdline + 10001) <= k )
      break;
    free((&cmdline)[4 * k + 4]);
  }
  return result;
}

//----- (08048F08) --------------------------------------------------------
signed int __cdecl printEnv()
{
  size_t v0; // eax@3
  size_t v1; // eax@3
  char *buf; // [sp+1Ch] [bp-Ch]@2

  if ( *(&cmdline + 11002) == (char *)2 )
  {
    buf = getenv(*(&cmdline + 10003));
    if ( buf )
    {
      v0 = strlen(*(&cmdline + 10003));
      write((int)*(&cmdline + 11004), *(&cmdline + 10003), v0);
      write((int)*(&cmdline + 11004), L"", 1u);
      v1 = strlen(buf);
      write((int)*(&cmdline + 11004), buf, v1);
      write((int)*(&cmdline + 11004), L"|=\n", 1u);
    }
  }
  return 1;
}

//----- (08048FC4) --------------------------------------------------------
signed int __cdecl setEnv()
{
  if ( *(&cmdline + 11002) == (char *)3 )
    setenv(*(&cmdline + 10003), *(&cmdline + 10004), 1);
  return 1;
}

//----- (08048FFA) --------------------------------------------------------
ssize_t __cdecl getResult(int fd, void *buf)
{
  fcntl(fd, 4, 2048);
  return read(fd, buf, 0xF4240u);
}

//----- (0804903D) --------------------------------------------------------
void __cdecl sendResult(const char *buf)
{
  size_t v1; // eax@1

  v1 = strlen(buf);
  write((int)*(&cmdline + 11004), buf, v1);
  bzero((void *)buf, 0xF4240u);
}

//----- (0804907C) --------------------------------------------------------
int __cdecl closePipes(int a1, int a2)
{
  close(*(_DWORD *)(a1 + 4));
  close(*(_DWORD *)a1);
  close(*(_DWORD *)(a2 + 4));
  return close(*(_DWORD *)a2);
}

//----- (080490BE) --------------------------------------------------------
int __cdecl exeCmd(unsigned int a1)
{
  int v1; // ecx@5
  size_t v2; // eax@18
  size_t v3; // eax@22
  size_t v4; // eax@25
  int result; // eax@27
  signed int i; // [sp+14h] [bp-F4274h]@3
  int buf; // [sp+18h] [bp-F4270h]@16
  signed int j; // [sp+1Ch] [bp-F426Ch]@24
  __pid_t v9; // [sp+20h] [bp-F4268h]@10
  int fd; // [sp+24h] [bp-F4264h]@1
  int v11; // [sp+28h] [bp-F4260h]@16
  int v12; // [sp+2Ch] [bp-F425Ch]@8
  int v13; // [sp+30h] [bp-F4258h]@16
  int pipedes; // [sp+34h] [bp-F4254h]@16
  int v15; // [sp+38h] [bp-F4250h]@18
  int v16; // [sp+F427Ch] [bp-Ch]@1

  v16 = *MK_FP(__GS__, 20);
  if ( pipe(&fd) < 0 )
    errexit("init pipe fail\n");
  for ( i = 0; i <= 1; ++i )
  {
      //4 * 2 * (i + 5502) = 4 * ((2* i + 11004) + 2)
    if ( !strcmp(*(&cmdline + 10002), (&cmdline)[8 * (i + 5502) + 8]) )
    {
      ((void (*)(void))(&cmdline)[8 * (i + 5502) + 4])();
      goto LABEL_27;
    }
  }
  if ( pipe(&v12) < 0 )
    errexit("init pipe fail\n");
  v9 = fork();
  if ( v9 < 0 )
    errexit("fork fail\n");
  if ( v9 <= 0 )
  {
    close(fd);
    close(v12);
    dup2(v11, 1);
    dup2(v13, 2);
    close(v11);
    close(v13);
    pipe(&pipedes);
    buf = *(_DWORD *)(front + 1000004);
    savefd = dup(0);
    while ( buf )
    {
      if ( !*(_DWORD *)(buf + 1000000) )
      {
        fcntl(v15, 4, 2048);
        v2 = strlen((const char *)buf);
        write(v15, (const void *)buf, v2);
        dup2(pipedes, 0);
      }
      buf = *(_DWORD *)(buf + 1000004);
    }
    close(v15);
    close(pipedes);
    if ( execvp(*(&cmdline + 10002), &cmdline + 10002) == -1 )
    {
      write((int)*(&cmdline + 11004), "Unknown Command: [", 0x12u);
      v3 = strlen(*(&cmdline + 10002));
      write((int)*(&cmdline + 11004), *(&cmdline + 10002), v3);
      write((int)*(&cmdline + 11004), "]\n", 2u);
      *(&cmdline + 10001) = 0;
    }
    exit(0);
  }
  while ( wait(0) != v9 )
    ;
  if ( a1 <= 4 )
    JUMPOUT(__CS__, off_8049EEC[a1]);
  for ( j = 0; (signed int)*(&cmdline + 11002) > j; ++j )
  {
    v4 = strlen((&cmdline)[4 * (j + 10000) + 8]);
    bzero((&cmdline)[4 * (j + 10000) + 8], v4);
    free((&cmdline)[4 * (j + 10000) + 8]);
  }
LABEL_27:
  result = *MK_FP(__GS__, 20) ^ v16;
  if ( *MK_FP(__GS__, 20) != v16 )
    __stack_chk_fail(v1);
  return result;
}
// 8048720: using guessed type int __fastcall __stack_chk_fail(_DWORD);
// 8049EEC: using guessed type int (__cdecl *off_8049EEC[5])(int, int);
// 804C0C0: using guessed type int front;

//----- (080496E8) --------------------------------------------------------
int __cdecl nextLine()
{
  int s; // [sp+14h] [bp-14h]@1
  int pipedes; // [sp+18h] [bp-10h]@1
  int fd; // [sp+1Ch] [bp-Ch]@6

  memset(cmdline, 0, 4u);
  free(cmdline);
  pipe(&pipedes);
  s = *(_DWORD *)(front + 1000004);
  savefd = dup(0);
  while ( s )
  {
    if ( !*(_DWORD *)(s + 1000000) )
      delPipe((char *)s);
    --*(_DWORD *)(s + 1000000);
    s = *(_DWORD *)(s + 1000004);
  }
  close(fd);
  return close(pipedes);
}
// 804C0C0: using guessed type int front;

//----- (0804979B) --------------------------------------------------------
void __cdecl main(int a1, int a2)
{
  size_t v2; // eax@2
  signed __int16 v3; // [sp+11h] [bp-CFh]@2
  char v4; // [sp+13h] [bp-CDh]@2
  int v5; // [sp+14h] [bp-CCh]@1
  char **v6; // [sp+18h] [bp-C8h]@1
  signed int v7; // [sp+1Ch] [bp-C4h]@1
  signed int v8; // [sp+20h] [bp-C0h]@1
  signed int v9; // [sp+24h] [bp-BCh]@1
  signed int v10; // [sp+28h] [bp-B8h]@1
  signed int v11; // [sp+2Ch] [bp-B4h]@1
  signed int v12; // [sp+30h] [bp-B0h]@1
  signed int v13; // [sp+34h] [bp-ACh]@1
  signed int v14; // [sp+38h] [bp-A8h]@1
  signed int v15; // [sp+3Ch] [bp-A4h]@1
  signed int v16; // [sp+40h] [bp-A0h]@1
  signed int v17; // [sp+44h] [bp-9Ch]@1
  signed int v18; // [sp+48h] [bp-98h]@1
  signed int v19; // [sp+4Ch] [bp-94h]@1
  signed int v20; // [sp+50h] [bp-90h]@1
  signed int v21; // [sp+54h] [bp-8Ch]@1
  signed int v22; // [sp+58h] [bp-88h]@1
  signed int v23; // [sp+5Ch] [bp-84h]@1
  signed int v24; // [sp+60h] [bp-80h]@1
  signed int v25; // [sp+64h] [bp-7Ch]@1
  signed int v26; // [sp+68h] [bp-78h]@1
  signed int v27; // [sp+6Ch] [bp-74h]@1
  signed int v28; // [sp+70h] [bp-70h]@1
  signed int v29; // [sp+74h] [bp-6Ch]@1
  signed int v30; // [sp+78h] [bp-68h]@1
  signed int v31; // [sp+7Ch] [bp-64h]@1
  signed int v32; // [sp+80h] [bp-60h]@1
  signed int v33; // [sp+84h] [bp-5Ch]@1
  signed int v34; // [sp+88h] [bp-58h]@1
  signed int v35; // [sp+8Ch] [bp-54h]@1
  signed int v36; // [sp+90h] [bp-50h]@1
  signed int v37; // [sp+94h] [bp-4Ch]@1
  signed int v38; // [sp+98h] [bp-48h]@1
  signed int v39; // [sp+9Ch] [bp-44h]@1
  signed int v40; // [sp+A0h] [bp-40h]@1
  signed int v41; // [sp+A4h] [bp-3Ch]@1
  signed int v42; // [sp+A8h] [bp-38h]@1
  signed int v43; // [sp+ACh] [bp-34h]@1
  signed int v44; // [sp+B0h] [bp-30h]@1
  signed int v45; // [sp+B4h] [bp-2Ch]@1
  signed int v46; // [sp+B8h] [bp-28h]@1
  signed int v47; // [sp+BCh] [bp-24h]@1
  signed int v48; // [sp+C0h] [bp-20h]@1
  signed int v49; // [sp+C4h] [bp-1Ch]@1
  signed int v50; // [sp+C8h] [bp-18h]@1
  signed int v51; // [sp+CCh] [bp-14h]@1
  signed int v52; // [sp+D0h] [bp-10h]@1
  signed int v53; // [sp+D4h] [bp-Ch]@1
  signed int v54; // [sp+D8h] [bp-8h]@1
  int v55; // [sp+DCh] [bp-4h]@1

  v55 = *MK_FP(__GS__, 20);
  v5 = 1;
  v6 = passCmdline();
  setenv("PATH", "bin:../bin", 1);
  setenv("PWD", "/home/nphw1/root", 1);
  chdir("/home/nphw1/root");
  v6[11004] = (char *)1;
  v7 = 707406378;
  v8 = 707406378;
  v9 = 707406378;
  v10 = 707406378;
  v11 = 707406378;
  v12 = 707406378;
  v13 = 707406378;
  v14 = 707406378;
  v15 = 707406378;
  v16 = 707406378;
  v17 = 707406378;
  v18 = 707406378;
  v19 = 707406378;
  v20 = 707406378;
  v21 = 707406378;
  v22 = 666154;
  v23 = 1461725738;
  v24 = 1868786789;
  v25 = 1948280173;
  v26 = 1752440943;
  v27 = 1852383333;
  v28 = 1836216166;
  v29 = 1869182049;
  v30 = 1702043758;
  v31 = 1919252082;
  v32 = 2037194796;
  v33 = 1987208563;
  v34 = 1848537701;
  v35 = 779449443;
  v36 = 779445349;
  v37 = 539916148;
  v38 = 666154;
  v39 = 707406378;
  v40 = 707406378;
  v41 = 707406378;
  v42 = 707406378;
  v43 = 707406378;
  v44 = 707406378;
  v45 = 707406378;
  v46 = 707406378;
  v47 = 707406378;
  v48 = 707406378;
  v49 = 707406378;
  v50 = 707406378;
  v51 = 707406378;
  v52 = 707406378;
  v53 = 707406378;
  v54 = 666154;
  write(v5, &v7, 0x3Fu);
  write(v5, &v23, 0x3Fu);
  write(v5, &v39, 0x3Fu);
  while ( 1 )
  {
    do
    {
      v3 = 8229;
      v4 = 0;
      v2 = strlen((const char *)&v3);
      write(v5, &v3, v2);
      *v6 = 0;
      readline(0, (void **)v6);
    }
    while ( !*v6 );
    if ( !strcmp(*v6, "exit") )
      exit(0);
    splitCmdline();
    parseArgv();
    nextLine();
  }
}

//----- (08049AD0) --------------------------------------------------------
int __cdecl passPipe()
{
  int v0; // eax@1
  int v1; // edx@1
  int v2; // eax@1

  v0 = (int)malloc(0xF424Cu);
  rear = v0;
  front = v0;
  *(_DWORD *)(v0 + 1000004) = 0;
  *(_DWORD *)(v0 + 1000004) = *(_DWORD *)(v0 + 1000004);
  v1 = front;
  v2 = rear;
  *(_DWORD *)(rear + 1000008) = 0;
  *(_DWORD *)(v1 + 1000008) = *(_DWORD *)(v2 + 1000008);
  return rear;
}
// 804C0C0: using guessed type int front;
// 804C0C4: using guessed type int rear;

//----- (08049B45) --------------------------------------------------------
void *__cdecl addPipe(const char *src, int a2)
{
  void *result; // eax@3
  void *dest; // [sp+1Ch] [bp-Ch]@1

  dest = malloc(0xF424Cu);
  if ( !*(_DWORD *)(front + 1000004) )
    *(_DWORD *)(front + 1000004) = dest;
  strcpy((char *)dest, src);
  *((_DWORD *)dest + 250000) = a2;
  *((_DWORD *)dest + 250001) = 0;
  *((_DWORD *)dest + 250002) = rear;
  *(_DWORD *)(rear + 1000004) = dest;
  result = dest;
  rear = (int)dest;
  return result;
}
// 804C0C0: using guessed type int front;
// 804C0C4: using guessed type int rear;

//----- (08049BC9) --------------------------------------------------------
void __cdecl delPipe(char *s)
{
  size_t v1; // eax@3

  if ( s )
  {
    if ( *((_DWORD *)s + 250001) )
    {
      *(_DWORD *)(*((_DWORD *)s + 250002) + 1000004) = *((_DWORD *)s + 250001);
      *(_DWORD *)(*((_DWORD *)s + 250001) + 1000008) = *((_DWORD *)s + 250002);
      v1 = strlen(s);
      bzero(s, v1);
      free(s);
    }
  }
}

//----- (08049C3B) --------------------------------------------------------
void errexit(const char *a1, ...)
{
  char s; // [sp+1Ch] [bp-40Ch]@1
  int v2; // [sp+41Ch] [bp-Ch]@1
  va_list va; // [sp+434h] [bp+Ch]@1

  va_start(va, a1);
  v2 = *MK_FP(__GS__, 20);
  vsprintf(&s, a1, va);
  fprintf(stderr, "ERROR: %s\n", &s, a1);
  exit(1);
}

//----- (08049CAE) --------------------------------------------------------
void __cdecl myexit(int status)
{
  exit(status);
}

//----- (08049CBF) --------------------------------------------------------
__pid_t __cdecl reaper()
{
  __pid_t result; // eax@2
  int stat_loc; // [sp+1Ch] [bp-Ch]@2

  do
  {
    result = wait3(&stat_loc, 1, 0);
    if ( result < 0 )
      break;
    result = stat_loc;
  }
  while ( stat_loc );
  return result;
}

//----- (08049CF1) --------------------------------------------------------
signed int __cdecl readline(int fd, void **a2)
{
  char buf; // [sp+1Fh] [bp-19h]@2
  int i; // [sp+20h] [bp-18h]@1
  int j; // [sp+24h] [bp-14h]@8
  int v6; // [sp+28h] [bp-10h]@2
  void *s; // [sp+2Ch] [bp-Ch]@8

  for ( i = 1; ; ++i )
  {
    v6 = read(fd, &buf, 1u);
    if ( v6 != 1 )
      break;
    if ( buf == 10 )
      return i;
    if ( buf != 13 && buf != 47 && buf != 59 && buf != 46 )
    {
      s = malloc(i + 1);
      bzero(s, i + 1);
      for ( j = 0; j < i; ++j )
      {
        if ( *a2 )
          *((_BYTE *)s + j) = *((_BYTE *)*a2 + j);
      }
      if ( *a2 )
        free(*a2);
      *((_BYTE *)s + i - 1) = buf;
      *a2 = s;
    }
  }
  if ( v6 )
    return -1;
  if ( i == 1 )
    return 0;
  return i;
}

